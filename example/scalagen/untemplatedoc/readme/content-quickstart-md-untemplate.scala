// DO NOT HAND EDIT -- Autogenerated from 'content-quickstart.md.untemplate' at 2025-08-17T02:19:49.534656Z
package untemplatedoc.readme

import java.io.{Writer,StringWriter}
import scala.collection.{immutable,mutable}

import untemplatedoc.*
import java.nio.file.Files
import com.mchange.codegenutil.*



val Untemplate_content_quickstart_md = new untemplate.Untemplate[Int,SubsectionMeta]:
  val UntemplateFunction                    : untemplate.Untemplate[Int,SubsectionMeta] = this
  val UntemplateName                        : String = "content_quickstart_md"
  val UntemplatePackage                     : String = "untemplatedoc.readme"
  val UntemplateInputName                   : String = "level"
  val UntemplateInputTypeDeclared           : String = "Int"
  val UntemplateInputTypeCanonical          : Option[String] = untemplate.Macro.nonEmptyStringOption( untemplate.Macro.recursiveCanonicalName[Int] )
  val UntemplateInputDefaultArgument        : Option[Int] = (None : Option[Int])
  val UntemplateOutputMetadataTypeDeclared  : String = "SubsectionMeta"
  val UntemplateOutputMetadataTypeCanonical : Option[String] = untemplate.Macro.nonEmptyStringOption( untemplate.Macro.recursiveCanonicalName[SubsectionMeta] )
  val UntemplateHeaderNote                  : String = ""
  val UntemplateLastModified                : Option[Long] = Some(1755397184524L)
  val UntemplateSynthetic                   : Boolean = false

  val UntemplateAttributes : immutable.Map[String,Any] = immutable.Map.empty


  def apply(level : Int) : untemplate.Result[SubsectionMeta] =
    val writer             : StringWriter = new StringWriter(35820)
    val attrs              : immutable.Map[String,Any] = UntemplateAttributes
    var mbMetadata         : Option[SubsectionMeta] = None
    var outputTransformer  : Function1[untemplate.Result[SubsectionMeta],untemplate.Result[SubsectionMeta]] = readme.subsection_content_transformer_md

    val title = "Quickstart"
    mbMetadata = Some( SubsectionMeta( level, title ) )

      val block0 = new Function0[String]:
        def apply() : String =
          "\nOK. First let's get a mill project setup:\n\n```plaintext\n% mkdir myproject\n% cd myproject\n% curl -O https://raw.githubusercontent.com/com-lihaoyi/mill/refs/heads/main/mill\n% chmod +x mill\n```\n\nWe'll go ahead and define `src` and `untemplate` directories.\n\n```plaintext\n% mkdir src untemplate\n```\n\nNow let's setup a minimalist `build.mill` file, however you like to do that:\n\n```scala\n//| mill-version: 1.0.3\n//| mill-jvm-version: 17\n//| mvnDeps: [\"com.mchange::untemplate-mill:" + ( untemplateVersion ) +
          "\"]\n//+---------------------------------------------------------------\npackage build\n\nimport mill.*, scalalib.*\n\nimport untemplate.mill.UntemplateModule\n\nobject `package` extends UntemplateModule:\n  override def scalaVersion = \"3.3.6\"\n```\n\nGreat. Let's work in the `mypkg` package. Let's create a director under `untemplate`.\n\n```plaintext\n% mkdir untemplate/mypkg\n```\n\nOK! Let's drop our first untemplate into there. We'll name the following file `hello.txt.untemplate`:\n\n```plaintext\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter.RFC_1123_DATE_TIME\n\n(name : String = \"world\")[]~()>               # Header delimeter, text start!\n\n  \\      |       /\n-- * GREETINGS! * --\n  /      |       \\\n\nI am so happy to meet you.\nPlease allow me to effuse:\n\n<()                                           # text end!\nfor (i <- 0 to 20)\n()---->------------>---------->-------------> # This is a \"long delimeter\", text start!\n<( \"-\" * i )>> Hello <( name )>!!!\n<-----<------------<----------<------------() # text end!\n\nval now = ZonedDateTime.now()\n\n()>                                           # text start!\n\n----------------------------------------------------------\nGenerated for <( name )> on <( RFC_1123_DATE_TIME.format( now ) )>\n  |\nLove! :P\n```\n\nLet's put a simple program, under `src/hello.scala`:\n\n```scala\n@main\ndef hello() : Unit = println(mypkg.hello_txt())\n```\n\n(Note how we dropped the `.untemplate` suffix, and the '.' in the name became an underscore. '-' characters also become underscore.)\n\nNow it's just...\n\n```plaintext\n% ./mill run\n```\n\nCongratulations! You've just created and used your first untemplate!\n\nSome exercises to try out:\n\n1. Our untemplate actually accepts a `String` name for its argument.\n   Modify your program so you supply a name to the untemplate function.\n   (You can hardcode your name, or let it be a command-line argument.)\n\n2. Most real applications will want an index of untemplates. Add to your\n   `build.mill` file the following line:\n   ```scala\n   override def untemplateIndexNameFullyQualified : Option[String] = Some(\"mypkg.Untemplates\")\n   ```\n   Be careful about Scala 3 indentation! This line needs to be inside your object `package`.\n\n   Now run `mill -i console`, and see if you can't list all the indexed untemplates.\n   (For now there's just one!) The index will be Scala `Map`, with the fully qualified names\n   of the untemplates as keys and the untemplate functions as values.\n\n   _**Hint:** The `toString` method of the untemplate functions include their type parameterizations,\n   but the compiler only knows them as `untemplate.Untemplate[Nothing,Any]`. Try\n   ```scala\n   mypkg.Untemplates.head(1).asInstanceOf[untemplate.Untemplate[String,Nothing]](\"my friend\")\n   ```\n   You'll need to use `asInstanceOf` on untemplates retrieved via the index, and you'll generally\n   want to deploy conventions so you know their argument and return metadata types from\n   their package or name.\n"
      writer.write(block0())

    outputTransformer( untemplate.Result( mbMetadata, writer.toString ) )

  end apply
end Untemplate_content_quickstart_md

def content_quickstart_md(level : Int) : untemplate.Result[SubsectionMeta] = Untemplate_content_quickstart_md( level )
