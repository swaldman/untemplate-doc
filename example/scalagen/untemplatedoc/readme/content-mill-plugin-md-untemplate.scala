// DO NOT HAND EDIT -- Autogenerated from 'content-mill-plugin.md.untemplate' at 2025-08-16T22:54:39.626582Z
package untemplatedoc.readme

import java.io.{Writer,StringWriter}
import scala.collection.{immutable,mutable}

import untemplatedoc.*
import java.nio.file.Files
import com.mchange.codegenutil.*



val Untemplate_content_mill_plugin_md = new untemplate.Untemplate[Int,SubsectionMeta]:
  val UntemplateFunction                    : untemplate.Untemplate[Int,SubsectionMeta] = this
  val UntemplateName                        : String = "content_mill_plugin_md"
  val UntemplatePackage                     : String = "untemplatedoc.readme"
  val UntemplateInputName                   : String = "level"
  val UntemplateInputTypeDeclared           : String = "Int"
  val UntemplateInputTypeCanonical          : Option[String] = untemplate.Macro.nonEmptyStringOption( untemplate.Macro.recursiveCanonicalName[Int] )
  val UntemplateInputDefaultArgument        : Option[Int] = (None : Option[Int])
  val UntemplateOutputMetadataTypeDeclared  : String = "SubsectionMeta"
  val UntemplateOutputMetadataTypeCanonical : Option[String] = untemplate.Macro.nonEmptyStringOption( untemplate.Macro.recursiveCanonicalName[SubsectionMeta] )
  val UntemplateHeaderNote                  : String = ""
  val UntemplateLastModified                : Option[Long] = Some(1755384713500L)
  val UntemplateSynthetic                   : Boolean = false

  val UntemplateAttributes : immutable.Map[String,Any] = immutable.Map.empty


  def apply(level : Int) : untemplate.Result[SubsectionMeta] =
    val writer             : StringWriter = new StringWriter(29700)
    val attrs              : immutable.Map[String,Any] = UntemplateAttributes
    var mbMetadata         : Option[SubsectionMeta] = None
    var outputTransformer  : Function1[untemplate.Result[SubsectionMeta],untemplate.Result[SubsectionMeta]] = readme.subsection_content_transformer_md

    val title = "Mill Plugin"
    mbMetadata = Some( SubsectionMeta( level, title ) )

      val block0 = new Function0[String]:
        def apply() : String =
          "\nThe easiest way to incorporate untemplates into your project is to build your project with\n[mill](https://mill-build.org/mill/index.html), and to use the untemplate mill plugin.\n\nHere's a very simple `build.mill. file:\n\n```plaintext\n//| mill-version: 1.0.3\n//| mill-jvm-version: 17\n//| mvnDeps: [\"com.mchange::untemplate-mill:" + ( untemplateVersion ) +
          "\"]\n//+---------------------------------------------------------------\npackage build\n\nimport mill.*, scalalib.*\n\nobject `package` extends UntemplateModule:\n  override def scalaVersion = \"3.3.6\"\n\n  // we'll build an index!\n  override def untemplateIndexNameFullyQualified : Option[String] = Some(\"mypkg.IndexedUntemplates\")\n\n  override def mvnDeps = Task {\n    super.mvnDeps() ++\n      Seq (\n        // your project's dependencies go here\n      )\n  }\n```\n\nThat's all you need!\n\nPlace your untemplate under the directory called `untemplate`. Typically you'll define a directory\nhierarchy beneath this directory, which will map in old-school Java style to the package names beneath\nwhich your generated untemplate functions will be named. (You can [override this behavior](#untemplates-packages-and-imports) if you wish.)\n\nWe've also [generated an index](indexes) of all generated untemplates, which you can access as `mypkg.IndexedUntemplates`.\n\nThe `mill` plugin is very full-featured:\n\n* You can [provide a `Customizer.Selector`](#customizers) to provide fine-grained customizations of your generated untemplates.\n  Add to your `build.mill` file\n  ```scala\n  override def untemplateSelectCustomizer : untemplate.Customizer.Selector = ...\n  ```\n\n* You can replace the default location for untemplate source code via\n  ```scala\n  override def untemplateSourcesFolders : Seq[os.SubPath] = Seq(\"notes\")\n  ```\n  Note that these paths will be defined relative to your mill build's module directory.\n\n  or, much more commonly, preserve the default untemplate directory while\n  adding additional source locations:\n  ```scala\n  override def untemplateSourcesFolders = super.untemplateSourcesFolders :+ \"notes\"\n  ```\n\n* You can add _prefix packages_ in a source-directory-specific way, to avoid having\n  to define your untemplates deep in a directory hierarchy:\n  ```scala\n  override def untemplateSourcesPrefixPackagesFromModuleDir : Map[String,String] = Map(\"notes\" -> \"mypkg.usercontent.note\")\n  ```\n  Now, any package inferred from the location of your untemplate under `notes` will `mypkg.usercontent.note`\n  prepended to it.\n\n  Again, strings given as keys represent paths relative to your build's module directory.\n  Packages are supplied in the usual '.'-delimited format\n\n* Less commonly, you can insist that your untemplates be generated to a single directory, rather than into\n  a full hierarchy matching package names. That would be\n  ```scala\n  override def untemplateFlatten = Task(true) // rare\n  ```\n\n\n\n"
      writer.write(block0())

    outputTransformer( untemplate.Result( mbMetadata, writer.toString ) )

  end apply
end Untemplate_content_mill_plugin_md

def content_mill_plugin_md(level : Int) : untemplate.Result[SubsectionMeta] = Untemplate_content_mill_plugin_md( level )
