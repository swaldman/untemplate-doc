import java.nio.file.Files
import com.mchange.codegenutil.*

val title = "Functional templates"

val subsections = Vector (
  Subsection("Untemplates are functions"),
  Subsection("Naming the top-level untemplate function"),
  Subsection("Untemplates, packages, and imports"),
  Subsection("Reflection"),

)

mbMetadata = Some( Subsection( title, subsections.toList ) )

(level : Int)[Subsection]~()>

<( hashHeader(level) )> <( title )>

<( hashHeader(level+1) )> <( subsections(0).title )>

Every untemplate defines a Scala function. By default, from a file called `awesomeness.md.untemplate`, this
function would look like...

```scala
def awesomeness_md( input : immutable.Map[String,Any] ) : untemplate.Result[Nothing]
```

The top-level function accepts a single, author-specifiable input. (`immutable.Map[String,Any]` is just a default.)

It returns the template output as a simple `String`, along with any metadata that untemplate chooses to provide.

More specifically, each template returns a

```scala
package untemplate

case class Result[+A]( mbMetadata : Option[A], text : String)`.
```

Untemplate authors may (optionally!) specify the input name and type of the untemplate function, and output metadata type,
in the header delimiter:

```scala
\(sourceMarkdown : String)[immutable.Map[String,String]]~()>
```
This header causes the generated untemplate function to require a `String` input, which the template author can work with in the
template as `sourceMarkdown`.

The function will return whatever text it generates, along with an `Option[immutable.Map[String,String]]`.

By default, this returned metadata will be `None`, but the template can provide `Some(metadata)` by overwriting the `var` called `mbMetadata`.

> :blush: **It's okay!** <br/>
> Ick, it's a `var`! It's okay. `mbMetadata` is a strictly local variable, in the single-threaded context of a function
> call. Your function will remain very functional as long as the input type and output metadata types that you specify
> are immutable.

<( hashHeader(level+1) )> <( subsections(1).title )>

Every text block within an untemplate can be a function.

Ordinarily, text blocks just print themselves
automatically into the generated `String`. However, if you embed a name in the `\()>` delimeter that begins
the block, like `\(entry)>`, then nothing is automatically printed into the `String`. Instead you will have a function
`entry()` to work with in code blocks.

The block function will return a simple `String`.

Use `writer.write(entry())` to generate text into untemplate output.

Let's try to redo our ["Loopy" template](#repeatable-omittable-blocks) making the text block that prints `# Loopy` into a function.

Instead of beginning our blocks with `\()>`, we embed a valid scala identifier into the parenthesis,
like `\(loopy)>`.

However, doing that carries with it some complications. If we just try that in our loopy markdown
file as it was, we'll get compilation errors.

The file...
```scala
<()
writer.writeln(Files.readString(loopy2badSrc).trim)
()>
```
And the ickies...
```
[info] compiling 7 Scala sources to /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/classes ...
[error] -- [E018] Syntax Error: /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/src_managed/main/untemplate/untemplatedoc/untemplate_loopy2_bad_md.scala:19:26
[error] 19 |    for (i <- 0 until num)
[error]    |                          ^
[error]    |                          expression expected but val found
[error]    |
[error]    | longer explanation available when compiling with `-explain`
[error] -- [E006] Not Found Error: /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/src_managed/main/untemplate/untemplatedoc/untemplate_loopy2_bad_md.scala:23:18
[error] 23 |    def loopy() = block0()
[error]    |                  ^^^^^^
[error]    |                  Not found: block0
[error]    |
[error]    | longer explanation available when compiling with `-explain`
[error] two errors found
[error] (Compile / compileIncremental) Compilation failed
```

Before things worked, because when we're just printing an expression to output, we indent the call to write in
the generated code so that it falls inside of any loops, if expressions, or other language constructs that the
prior code block has set up.

If we are going to want to treat the block as a reusable function, then we do not wish to enclose its declaration
in a very narrow scope. So, the function declaration provoked by named blocks is not indented, and named blocks
do not print by default.

If you want to use a named block, define it before you get to branches in your code flow,
then call your named function, which returns a `String` you can write. Let's fix our _Loopy_.

```scala
<()
writer.writeln(Files.readString(loopy2Src).trim)
()>
```

Not the loveliest file. But educational.
Here is the output...

```markdown
<()
writer.writeln(untemplatedoc.loopy2_md(immutable.Map.empty).text)
()>
```
([generated scala](<( sgenFor("loopy2_md") )>))

<( hashHeader(level+1) )> <( subsections(1).title )>

The `untemplate` app and file-system based tooling in the library will derive a default name for the
top-level generated function by transforming its filename. Untemplate are expected to have the suffix
`.untemplate`. The file you are reading is is [`README.md.untemplate`](<(readmeTopSrc)>), and [generates a
function](<( sgenFor("README_md") )>) like...

```scala
def README_md( input: immutable.Map[String,Any] ) : untemplate.Result[Nothing] = ???
```

> **Note** <br/>
> Return type `untemplate.Result[Nothing]` looks intimidating, but it's just a
> fancy wrapper for a `String`, as a field called `text`.
> The `[Nothing]` part just means there cannot be metadata attached to this result.

You can override the generated function name in
the same way block function names are defined. Header `\()[]~(untemplateDoc)>` would generate

```scala
def untemplateDoc( input: immutable.Map[String,Any] ) : untemplate.Result[Nothing] = ???
```
Header `\(pubDate: Instant)[]~(untemplateDoc)>` would generate

```scala
def untemplateDoc( pubDate: Instant ) : untemplate.Result[Nothing] = ???
```

Here's an example. Check out the [generated Scala](<( sgenFor("untemplateDoc") )>) code.

```scala
<()
writer.writeln(Files.readString(someOverridesSrc).trim)
()>
```
Which generates...

```markdown
<()
writer.writeln(untemplatedoc.untemplateDoc( java.time.Instant.now() ).text)
()>
```

> :question: **Question** <br/>
> What if you want to override the name of the top level function _and_ use
> the first text block as a function? You can!
>
> The header `\()[]~(mamaFunction.startText)>`
> would override the outer function name with `mamaFunction`, and turn the first text block into
> a function `startText()`.
>
> The header `\()[]~(.startText)>` would turn the first text block into a function
> called `startText()`, but leave the top-level function name alone.

<( hashHeader(level+1) )> <( subsections(2).title )>

Top-level untemplates are top-level functions, declared directly in a Scala package.
They are paired with implementations in the form of `Function0` objects, which are defined
as `Function_` prepended to the untemplate function name.

Untemplates are usually generated from a source directory, and the default behavior
is for packages to be inferred by the old-school Java convention. The directory hierarchy
beneath specified source directory, to the untemplate source file, will be mapped to a package
name (or dot-separated path of package names). Untemplate source
files placed in the top directory belong to the unnamed "default" package.

However, you can override this default by making an explicit package declaration in the header section of your
untemplate (that is, the section before a [header delimeter](#introduction)). If you wish all untemplates
to be generated into a single flat directory, regardless of where or how deeply they were found beneath the source
directory, you can set the option `flatten` to `true`.

Any package declarations or import statements in a header section go at the top-level, outside of
the untemplate-generated function.

All other code in the header section gets placed inside the generated function.

**This means that whatever input your header accepts is already in scope in the header section,
even though its name and type may be declared at the end of the header section, inside the header
delimeter.**

When generating untemplates, applications may specify a set of default imports that will be inserted into
all generated untemplates. So, if a static site generator makes use of a common set of types and utilities,
these can be made automatically available to all templates.

<( hashHeader(level+1) )> <( subsections(3).title )>

Within an untemplate, you have access to variables containing metainformation about the generated function:

```
UntemplateFunction:           `<(UntemplateFunction)>`
UntemplateName:               `<(UntemplateName)>`.
UntemplateInputType:          `<(UntemplateInputType)>`
UntemplateOutputMetadataType: `<(UntemplateOutputMetadataType)>`
```

The types are just Strings, and names _may not be fully qualified_.

`UntemplateFunction` is a reference to the `Function1` object that implements your untemplate.




