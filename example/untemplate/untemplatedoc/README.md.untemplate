import java.nio.file.{Path, Files}
import com.mchange.codegenutil.*

val usrcDir      = Path.of("src/main/untemplate")
val egenDir      = Path.of("example/untemplate")
val sgenDir      = Path.of("example/scalagen")
val ceciSrc      = usrcDir.resolve("untemplatedoc/ceci-nest-pas.md.untemplate")
val ceciScala    = sgenDir.resolve("untemplatedoc/untemplate_ceci_nest_pas_md.scala")
val ceci2Src     = usrcDir.resolve("untemplatedoc/ceci-nest-pas2.md.untemplate")
val loopySrc     = usrcDir.resolve("untemplatedoc/loopy.md.untemplate")
val loopy2badSrc = usrcDir.resolve("untemplatedoc/loopy2-bad.md.untemplate-off")
val loopy2Src    = usrcDir.resolve("untemplatedoc/loopy2.md.untemplate")
val thisFileSrc  = usrcDir.resolve("untemplatedoc/README.md.untemplate")

()[]~()>

# Untemplate Documentation

_This project documents the `untemplate` project. For the code, please see [swaldman/untemplate](https://github.com/swaldman/untemplate)._

## Introduction

Every once in a while, I find I need to build a little website for something.
I've become a fan of static site generators for that. I've worked with [hugo](https://gohugo.io/) and
[hexo](https://hexo.io/) and (paradox)[https://developer.lightbend.com/docs/paradox/current/index.html],
and they've all been great in their way.

But each time, I find myself spending a lot of time in their docs, figuring out each
SSG's specific DSLs, their tricks for doing things, what variables are exposed in
templates, etc.

I found myself yearning for simplicity. Why can't I just specify my static sites in my language
of choice? (For me, that's Scala these days.)

Static (and dynamic) site generation is in practice largely about templates. No one enjoys
embedding tons of HTML or Markdown or CSS in programming-language string literals, even
in modern languages that support multiline literals and interpolated strings.

But templates are a step along the slippery path to DSLs with clever, powerful features
that become the idiosyncracies and quirks I'm trying to escape. As much as possible, I
want my specification language to be straightforward Scala.

_Untemplate_ is my attempt to create the thinnest possible template veneer over vanilla Scala.
An untemplate is just a text file that optionally includes any of precisely four special delimeters:

| Delimeter | Description |
| --- | --- |
| `\<(expression)>` | Text-embedded Scala expression |
| `\()>` | Code / text boundary |
| `\<()` | Text / code boundary |
| `\()[]~>` | Header delimeter |

* `\<(expression)>` breaks out of plain text and inserts the result into the text
* `\()>` alone, at the beginning of a line, divides the file into a Scala code region, and a
text region. The region above is a Scala code region.
*  `\<()` alone, at the beginning of a line, is the inverse of the prior delimeter. It divides the
file into a text region and a Scala code region, with text in the region above, and code in the
region beneath.
*  `\()[]~>` is a special header delimiter. Like `\()>`, it divides the file into a Scala code
region above and a text region below. However, import statements in the code region above become
top-level imports in the generated file.

---

**Mnemonic:** _For every construct, whatever an "arrow", `<` or `>`, is pointing at is a text region,
whatever a parenthesis is adjacent to is code._

---

### Functional templates

Every untemplate is a Scala function that returns a simple `String`.

Every text block within an untemplate can be a function. Ordinarily, text blocks just print themselves
automatically into the generated String. However, if you embed a name in the `\()>` delimeter that begins
the block, like `\(entry)>`, nothing is automatically printed into the String, but you will have a function
`entry()` to work with in code blocks. `writer.write(entry)` will generate text into untemplate output.

You control the input type and name of the larger function that the full untemplate becomes by
specifying them in the header delimeter. Untemplate-generated functions always return a simple
`String`, and accept a single parameter. By default, that parameter is `input: immutable.Map[String,Any]`,
but if you choose a header delimeter like `\(users)[List[String]]~()>` then the input parameter will be
`users : List[String]`. By default the name of the generated function is determined by the untemplate
file name. The file you are reading is is `[README.md.untemplate](<(thisFileSrc)>)`, and generates a
function

```scala
def README_md( input: immutable.Map[String,Any] ) : String = ???
```

Not yet implemented, but you should soon be able to override the generated function name in
the same way block function names are defined. `\()[]~(userList)>` would become

```scala
def userList( input: immutable.Map[String,Any] ) : String = ???
```
`\(users)[List[String]]~(userList)>` would become

```scala
def userList( input: immutable.Map[String,Any] ) : String = ???
```

The easiest way to make sense of all this is by example.

## A Tour of Untemplate

Let's look at an untemplate so simple it seems not to be an untemplate at all.

```markdown
<()
writer.writeln(Files.readString(ceciSrc).trim)
()>
```
It's just a markdown file! But it's stored in an untemplate source directory as `ceci-nest-pas.md.untemplate`, so it gets
compiled to a simple scala function.

```scala
<()
writer.writeln(Files.readString(ceciScala).trim)
()>
```
### Embedded expressions

We'd like, of course, for our (un)template library to do a bit more than just spit out unmodified
text files though. Let's modify our example just a bit:

```markdown
<()
writer.writeln(Files.readString(ceci2Src).trim)
()>
```

Now, the [generated scala](<(sgenDir)>/untemplatedoc/untemplate_ceci_nest_pas2_md.scala) _would_ transform the markdown, like this:

```markdown
<()
writer.writeln(untemplatedoc.ceci_nest_pas2_md(immutable.Map.empty))
()>
```

The delimeter `\<( expression )>` causes the `expression` to be evaluated into the text.

---

<i>Note: This `README.md` is [generated by](<(sgenDir)>/untemplatedoc/untemplate_README_md.scala) an untemplate!
So how did I slip that delimiter in? Any
of the untemplate delimeters &mdash; there are only four! &mdash; can be escaped with a `\` character
just prior to them. The `\` will be stripped, then the delimeter included in the text unmodified.</i>

### Reapeatable, omitable, blocks

Often you'd like to do more than just embed a few very simple expressions in some text.
So, you can break up your text into code blocks and text blocks. Let's do that, and repeat
a block of text in a loop.

```markdown
<()
writer.writeln(Files.readString(loopySrc).trim)
()>
```

Let's get a look at what it produces:
```markdown
<()
writer.writeln(untemplatedoc.loopy_md(immutable.Map.empty))
()>
```

And again!
```markdown
<()
writer.writeln(untemplatedoc.loopy_md(immutable.Map.empty))
()>
```
([generated scala](<(sgenDir)>/untemplatedoc/untemplate_loopy_md.scala))

### Named blocks as functions

Maybe we want to use our expression-enriched text blocks in more than one place on our page.
We can name our blocks, and then they become functions. To do that, instead of beginning our
blocks with `\()>`, we embed a valid identifier in the parenthesis, like `\(loopy)>`.

However, that carries with it a few complications. If we just try that in our loopy markdown
file as it was, we'll get compilation errors.

The file...
```scala
<()
writer.writeln(Files.readString(loopy2badSrc).trim)
()>
```
And the ickies...
```
[info] compiling 1 Scala source to /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/classes ...
[error] -- [E018] Syntax Error: /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/src_managed/main/untemplate/untemplatedoc/untemplate_loopy2_bad_md.scala:11:24
[error] 11 |  for (i <- 0 until num)
[error]    |                        ^
[error]    |                        expression expected but val found
[error]    |
[error]    | longer explanation available when compiling with `-explain`
[error] -- [E006] Not Found Error: /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/src_managed/main/untemplate/untemplatedoc/untemplate_loopy2_bad_md.scala:15:57
[error] 15 |  def loopy( arg : immutable.Map[String,Any] = input ) = block0( arg )
[error]    |                                                         ^^^^^^
[error]    |                                                       Not found: block0
[error]    |
[error]    | longer explanation available when compiling with `-explain`
[error] two errors found
```

Before things worked, because when we're just printing an expression to output, we indent the call to write in
the generated code so that it falls inside of any loops, if expressions, or other language constructs that the
prior code block has set up.

If we are going to want to treat the block as a reusable function, we do not wish to enclose its declaration
in a very narrow scope. So, the declaration of named blocks is not indented, and named blocks do not print by default.
If you want to use a named block, define it before you get to branches in your code flow,
then call your named function, which returns a `String` you can write. Let's fix our _Loopy_.

```scala
<()
writer.writeln(Files.readString(loopy2Src).trim)
()>
```

Not the loveliest file. But educational.
Here is the output...

```markdown
<()
writer.writeln(untemplatedoc.loopy2_md(immutable.Map.empty))
()>
```
([generated scala](<(sgenDir)>/untemplatedoc/untemplate_loopy2_md.scala))
