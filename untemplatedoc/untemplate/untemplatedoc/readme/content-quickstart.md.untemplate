val title = "Quickstart"
mbMetadata = Some( SubsectionMeta( level, title ) )
(level : Int)[SubsectionMeta]~()>

OK. First let's get a mill project setup:

```plaintext
% mkdir myproject
% cd myproject
% curl -O https://raw.githubusercontent.com/com-lihaoyi/mill/refs/heads/main/mill
% chmod +x mill
```

We'll go ahead and define `src` and `untemplate` directories.

```plaintext
% mkdir src untemplate
```

Now let's setup a minimalist `build.mill` file, however you like to do that:

```scala
//| mill-version: 1.0.3
//| mill-jvm-version: 17
//| mvnDeps: ["com.mchange::untemplate-mill:<( untemplateVersion )>"]
//+---------------------------------------------------------------
package build

import mill.*, scalalib.*

import untemplate.mill.UntemplateModule

object `package` extends UntemplateModule:
  override def scalaVersion = "3.3.6"
```

Great. Let's work in the `mypkg` package. Let's create a director under `untemplate`.

```plaintext
% mkdir untemplate/mypkg
```

OK! Let's drop our first untemplate into there. We'll name the following file `hello.txt.untemplate`:

```plaintext
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter.RFC_1123_DATE_TIME

\(name : String = "world")[]~()>               # Header delimeter, text start!

  \      |       /
-- * GREETINGS! * --
  /      |       \

I am so happy to meet you.
Please allow me to effuse:

\<()                                           # text end!
for (i <- 0 to 20)
\()---->------------>---------->-------------> # This is a "long delimeter", text start!
\<( "-" * i )>> Hello \<( name )>!!!
\<-----<------------<----------<------------() # text end!

val now = ZonedDateTime.now()

\()>                                           # text start!

----------------------------------------------------------
Generated for \<( name )> on \<( RFC_1123_DATE_TIME.format( now ) )>
  |
Love! :P
```

Let's put a simple program, under `src/hello.scala`:

```scala
@main
def hello() : Unit = println(mypkg.hello_txt())
```

(Note how we dropped the `.untemplate` suffix, and the '.' in the name became an underscore. '-' characters also become underscore.)

Now it's just...

```plaintext
% ./mill run
```

Congratulations! You've just created and used your first untemplate!

Some exercises to try out:

1. Our untemplate actually accepts a `String` name for its argument.
   Modify your program so you supply a name to the untemplate function.
   (You can hardcode your name, or let it be a command-line argument.)

2. Most real applications will want an index of untemplates. Add to your
   `build.mill` file the following line:
   ```scala
   override def untemplateIndexNameFullyQualified : Option[String] = Some("mypkg.Untemplates")
   ```
   Be careful about Scala 3 indentation! This line needs to be inside your object `package`.

   Now run `mill -i console`, and see if you can't list all the indexed untemplates.
   (For now there's just one!) The index will be Scala `Map`, with the fully qualified names
   of the untemplates as keys and the untemplate functions as values.

   _**Hint:** The `toString` method of the untemplate functions include their type parameterizations,
   but the compiler only knows them as `untemplate.Untemplate[Nothing,Any]`. Try
   ```scala
   mypkg.Untemplates.head(1).asInstanceOf[untemplate.Untemplate[String,Nothing]]("my friend")
   ```
   You'll need to use `asInstanceOf` on untemplates retrieved via the index, and you'll generally
   want to deploy conventions so you know their argument and return metadata types from
   their package or name.
