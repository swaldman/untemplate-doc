
# Untemplate Docs

_This project documents the `untemplate` project. For the code, please see [swaldman/untemplate](https://github.com/swaldman/untemplate)._

## Introduction

TBD!

## Untemplate Basics

Let's look at an untemplate so simple it seems not to be an untemplate at all.

```markdown
# Ceci n'est pas...

Well, this is just a regular markdown file, with no
special untemplate constructs. But if we wish, we can treat
it as an unemplate, and it will be immortalized as a scala
function.
```
It's just a markdown file! But it's stored in an untemplate source directory as `ceci-nest-pas.md.untemplate`, so it gets
compiled to a simple scala function.

```scala
package untemplatedoc

import java.io.{Writer,StringWriter}
import scala.collection.*

def ceci_nest_pas_md(input : immutable.Map[String,Any]) : String =
  val writer = new StringWriter(131072) //XXX: Hardcoded initial capacity

    val block0 = new Function1[immutable.Map[String,Any],String]:
      def apply( input : immutable.Map[String,Any] ) : String =
        "# Ceci n'est pas...\n\nWell, this is just a regular markdown file, with no\nspecial untemplate constructs. But if we wish, we can treat\nit as an unemplate, and it will be immortalized as a scala\nfunction.\n\n"
    writer.write(block0( input ))
    
  writer.toString
  
end ceci_nest_pas_md
```
### Embedded expressions

We'd like, of course, for our (un)template library to do a bit more than just spit out unmodified
text files though. Let's modify our example just a bit:

```markdown
# Ceci n'est pas... <(math.random)>

Well, this is _almost_ just a regular markdown file, with no
special untemplate constructs. But if we wish, we can treat
it as an unemplate, and it will be immortalized as a scala
function.
```

Now, the [generated scala](example/scalagen/untemplatedoc/untemplate_ceci_nest_pas2_md.scala) _would_ transform the markdown, like this:

```markdown
# Ceci n'est pas... 0.34719255828001416

Well, this is _almost_ just a regular markdown file, with no
special untemplate constructs. But if we wish, we can treat
it as an unemplate, and it will be immortalized as a scala
function.


```

The delimeter `<( expression )>` causes the `expression` to be evaluated into the text.

---

<i>Note: This `README.md` is [generated by](sgenDir/untemplatedoc/untemplate_README_md.scala) an untemplate!
So how did I slip that delimiter in? Any
of the untemplate delimeters &mdash; there are only four! &mdash; can be escaped with a `\` character
just prior to them. The `\` will be stripped, then the delimeter included in the text unmodified.</i>

### Reapeatable, omitable, blocks

Often you'd like to do more than just embed a few very simple expressions in some text.
So, you can break up your text into code blocks and text blocks. Let's do that, and repeat
a block of text in a loop.

```markdown
val num = math.round(math.random * 10).toInt

for (i <- 0 until num)
()>
# Loopy
<()

if (num >= 5)
()>

And we're a winner! (num = <(num)>)
<()
else
()>

It sucks to be us. (num = <(num)>)
```

Let's get a look at what it produces:
```markdown
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy

And we're a winner! (num = 5)

```

And again!
```markdown
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy
# Loopy

And we're a winner! (num = 10)

```

### Named blocks as functions

Maybe we want to use our expression-enriched text blocks in more than one place on our page.
We can name our blocks, and then they become functions. To do that, instead of beginning our
blocks with `()>`, we embed a valid identifier in the parenthesis, like `(loopy)>`.

However, that carries with it a few complications. If we just try that in our loopy markdown
file as it was, we'll get compilation errors.

The file...
```scala
val num = math.round(math.random * 10).toInt

for (i <- 0 until num)
(loopy)>
# Loopy
<()

if (num >= 5)
()>

And we're a winner! (num = <(num)>)
<()
else
()>

It sucks to be us. (num = <(num)>)
```
And the ickies...
```
[info] compiling 1 Scala source to /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/classes ...
[error] -- [E018] Syntax Error: /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/src_managed/main/untemplate/untemplatedoc/untemplate_loopy2_bad_md.scala:11:24
[error] 11 |  for (i <- 0 until num)
[error]    |                        ^
[error]    |                        expression expected but val found
[error]    |
[error]    | longer explanation available when compiling with `-explain`
[error] -- [E006] Not Found Error: /Users/swaldman/Dropbox/BaseFolders/development-why/gitproj/untemplate-doc/target/scala-3.2.1/src_managed/main/untemplate/untemplatedoc/untemplate_loopy2_bad_md.scala:15:57
[error] 15 |  def loopy( arg : immutable.Map[String,Any] = input ) = block0( arg )
[error]    |                                                         ^^^^^^
[error]    |                                                       Not found: block0
[error]    |
[error]    | longer explanation available when compiling with `-explain`
[error] two errors found
```

Before things worked, because when we're just printing an expression to output, we indent the call to write in
the generated code so that it falls inside of any loops, if expressions, or other language constructs that the
prior code block has set up.

If we are going to want to treat the block as a reusable function, we do not wish to enclose its declaration
in a very narrow scope. So, the declaration of named blocks is not indented, and named blocks do not print by default.
If you want to use a named block, define it before you get to branches in your code flow,
then call your named function, which returns a `String` you can write. Let's fix our _Loopy_.

```scala
val num = math.round(math.random * 10).toInt

// comments in code blocks are fine!
// here is one way to turn text blocks into functions
(loopy)>
# Loopy
<()
for (i <- 0 until num) loopy()

// below is another, perhaps even simpler way to turn blocks into functions
//
// the indent of the if and else clauses must be lined up,
// the statement that prints becomes indented from that level!
def reportCard() : Unit =
  if (num >= 5)
()>

And we're a winner! (num = <(num)>)
<()
  else
()>

It sucks to be us. (num = <(num)>)
<()
reportCard()
```

Not the loveliest file. But educational.
Here is the output...

```markdown
# Loopy
# Loopy
# Loopy
# Loopy

It sucks to be us. (num = 4)

```
